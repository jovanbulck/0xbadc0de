diff --git a/3rdparty/optee/optee_os b/3rdparty/optee/optee_os
index d1634ce..2a360cd 160000
--- a/3rdparty/optee/optee_os
+++ b/3rdparty/optee/optee_os
@@ -1 +1 @@
-Subproject commit d1634ce8ff4a39242d4d333392e260e00405e471
+Subproject commit 2a360cdc34548d615e271de1e0cd0a3f698ac3d7
diff --git a/host/sgx/create.c b/host/sgx/create.c
index 71d3977..ca8ab72 100644
--- a/host/sgx/create.c
+++ b/host/sgx/create.c
@@ -378,14 +378,45 @@ done:
 **
 **==============================================================================
 */
+#include <sys/mman.h>
+#include <unistd.h>
+           
 
 static oe_result_t _initialize_enclave(oe_enclave_t* enclave)
 {
+    printf("_initialize_enclave(), sizeof(oe_enclave_t) = %ld\n", sizeof(oe_enclave_t));
+    printf("base addr = %p\n", (void*)enclave->addr);
+
     oe_result_t result = OE_UNEXPECTED;
     uint64_t result_out = 0;
 
-    OE_CHECK(oe_ecall(
-        enclave, OE_ECALL_INIT_ENCLAVE, (uint64_t)enclave, &result_out));
+    size_t sz = (size_t)sysconf(_SC_PAGESIZE);
+    printf("pagesize = %ld\n", sz);
+
+    const uint64_t to_map = enclave->addr - sz;
+
+    printf("now mapping %p...\n", (void*)to_map);
+
+    void* mapping = mmap((void*)to_map, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
+
+    if(mapping == MAP_FAILED)
+    {
+        perror("mapping failed"); 
+    }
+    else
+    {
+        printf("mapped at %p\n", mapping);
+    }
+
+    const uint64_t overlap = sizeof(oe_enclave_t) - 1; //sizeof(enclave->debug_enclave) + sizeof(enclave->simulate)+ sizeof(enclave->debug) + sizeof(enclave->num_ocalls) + sizeof(enclave->ocalls) ;
+    const uint64_t copy_to = enclave->addr - sizeof(oe_enclave_t) + overlap;
+
+    printf("pass oe_enclave_t (that begins in untrusted mem) at: %p ... %p xD\n", (void*)copy_to, (void*)(copy_to + sizeof(oe_enclave_t) - 1));
+
+    // Copy most stuff
+    memcpy((void*)copy_to, enclave, sizeof(oe_enclave_t) - overlap);
+
+    OE_CHECK(oe_ecall(enclave, OE_ECALL_INIT_ENCLAVE, (uint64_t)copy_to, &result_out));
 
     if (result_out > OE_UINT32_MAX)
         OE_RAISE(OE_FAILURE);
diff --git a/samples/helloworld/enclave/enc.c b/samples/helloworld/enclave/enc.c
index 512ef5f..4ae3c3a 100644
--- a/samples/helloworld/enclave/enc.c
+++ b/samples/helloworld/enclave/enc.c
@@ -8,6 +8,10 @@
 // sdk tool oeedger8r against the helloworld.edl file.
 #include "helloworld_t.h"
 
+#define TEST_BASE_OFFSET 0x2B4010
+
+uint8_t test = 0xabc;
+
 // This is the function that the host calls. It prints
 // a message in the enclave before calling back out to
 // the host to print a message from there too.
@@ -18,7 +22,37 @@ void enclave_helloworld()
     // host and calls fprintf from there. This is because
     // the fprintf function is not part of the enclave
     // as it requires support from the kernel.
-    fprintf(stdout, "Hello world from the enclave\n");
+    uint8_t* base = (uint8_t*)((uint64_t)(&test) - TEST_BASE_OFFSET);
+    fprintf(stdout, "test at %p, i.e. base at %p\n", (void*)&test, base);
+
+    // Dump beginning of enclave mem
+    for(size_t i = 0; i < 64; i++)
+    {
+        fprintf(stdout, "%02x ", base[i]);
+
+        if(i % 16 == 15)
+        {
+            fprintf(stdout, "\n");
+        }
+    }
+
+
+    // Dump oe_enclave struct
+    uint8_t* e = (uint8_t*)oe_get_enclave();
+
+    fprintf(stdout, "oe_enclave_t at %p: \n", e);
+
+
+    for(size_t i = 0; i < 1944; i++)
+    {
+        fprintf(stdout, "%02x ", e[i]);
+
+        if(i % 16 == 15)
+        {
+            fprintf(stdout, "\n");
+        }
+    }
+
 
     // Call back into the host
     oe_result_t result = host_helloworld();
diff --git a/samples/helloworld/host/host.c b/samples/helloworld/host/host.c
index 4e7f85f..2593487 100644
--- a/samples/helloworld/host/host.c
+++ b/samples/helloworld/host/host.c
@@ -4,11 +4,65 @@
 #include <openenclave/host.h>
 #include <stdio.h>
 
+#include <signal.h>
+#include <pthread.h>
+#include <unistd.h>
+
 // Include the untrusted helloworld header that is generated
 // during the build. This file is generated by calling the
 // sdk tool oeedger8r against the helloworld.edl file.
 #include "helloworld_u.h"
 
+/* async-signal-safe implementation of integer to string conversion.
+ *
+ * Null terminates the output string.
+ *
+ * The input buffer size must be large enough to contain the output,
+ * the caller must calculate it properly.
+ *
+ * @param[out] value  Input integer value to convert.
+ * @param[out] result Buffer to output to.
+ * @param[in]  base   Base to convert to.
+ * @return     Pointer to the end of the written string.
+ */
+char *itoa_safe(intmax_t value, char *result, int base) {
+    intmax_t tmp_value;
+    char *ptr, *ptr2, tmp_char;
+    if (base < 2 || base > 36) {
+        return NULL;
+    }
+
+    ptr = result;
+    do {
+        tmp_value = value;
+        value /= base;
+        *ptr++ = "ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[35 + (tmp_value - value * base)];
+    } while (value);
+    if (tmp_value < 0)
+        *ptr++ = '-';
+    ptr2 = result;
+    result = ptr;
+    *ptr-- = '\0';
+    while (ptr2 < ptr) {
+        tmp_char = *ptr;
+        *ptr--= *ptr2;
+        *ptr2++ = tmp_char;
+    }
+    return result;
+}
+
+void fault_handler(int signo, siginfo_t *info, void *extra)
+{
+	char buf[64] = "";
+    char* end = buf;
+
+    end = itoa_safe(signo, end, 16);
+    *end++ = '\n';
+    write(STDOUT_FILENO, buf, end - buf);
+
+    exit(1);
+}
+
 bool check_simulate_opt(int* argc, const char* argv[])
 {
     for (int i = 0; i < *argc; i++)
@@ -50,6 +104,19 @@ int main(int argc, const char* argv[])
         goto exit;
     }
 
+    // Install pf handler
+	struct sigaction sa;
+    sa.sa_flags = SA_SIGINFO;
+    sigemptyset(&sa.sa_mask);
+    sa.sa_sigaction = fault_handler;
+	/*if (sigaction(SIGSEGV, &sa, NULL) == -1) {
+		perror("sigusr: sigaction");
+		exit(1);
+	}*/
+
+    fprintf(stdout,"Fault handler installed...\n");
+
+
     // Create the enclave
     result = oe_create_helloworld_enclave(
         argv[1], OE_ENCLAVE_TYPE_AUTO, flags, NULL, 0, &enclave);
