diff --git a/enclave/core/sgx/calls.c b/enclave/core/sgx/calls.c
index 6671db5..af8322f 100644
--- a/enclave/core/sgx/calls.c
+++ b/enclave/core/sgx/calls.c
@@ -341,7 +341,8 @@ static void _handle_ecall(
     oe_result_t result = OE_OK;
 
     /* Insert ECALL context onto front of td_t.ecalls list */
-    Callsite callsite = {{0}};
+    Callsite callsite; // = {{0}};
+    memset(&callsite, 0, sizeof(Callsite));
     uint64_t arg_out = 0;
 
     td_push_callsite(td, &callsite);
diff --git a/host/sgx/linux/enter.S b/host/sgx/linux/enter.S
index 4957490..25625c8 100644
--- a/host/sgx/linux/enter.S
+++ b/host/sgx/linux/enter.S
@@ -4,6 +4,11 @@
 #include "../asmdefs.h"
 #include <openenclave/internal/context.inc>
 
+.data
+g_do_std:     .quad 0
+g_prev_df:    .quad 0
+
+.text
 //==============================================================================
 //
 // void __morestack(
@@ -45,6 +50,82 @@
 // We need an extra OE_WORDSIZE to keep the stack aligned.
 #define PARAMS_SPACE    ((12*OE_WORDSIZE) + OE_CONTEXT_SIZE)
 
+#if defined(__i386) || defined(__i386__)
+#  define LINUX32       1
+#  define SE_WORDSIZE   4
+
+/* Generic argument picker for `naked' functions */
+#  define naked_arg0    4(%esp)
+#  define naked_arg1    8(%esp)
+#  define naked_arg2   12(%esp)
+#  define naked_arg3   16(%esp)
+
+#  define xax eax
+#  define xbx ebx
+#  define xcx ecx
+#  define xdx edx
+
+#  define xsi esi
+#  define xdi edi
+#  define xbp ebp
+#  define xsp esp
+#elif defined(__x86_64) || defined(__x86_64__)
+#  define LINUX64       1
+#  define SE_WORDSIZE   8
+
+/* For x86_64, the first six parameters are passed by
+ * rdi, rsi, rdx, rcx, r8, r9.
+ */
+#  define naked_arg0    %rdi
+#  define naked_arg1    %rsi
+#  define naked_arg2    %rdx
+#  define naked_arg3    %rcx
+
+#  define xax rax
+#  define xbx rbx
+#  define xcx rcx
+#  define xdx rdx
+
+#  define xsi rsi
+#  define xdi rdi
+#  define xbp rbp
+#  define xsp rsp
+#else
+#  error unknown platform!
+#endif
+
+.macro lea_pic symbol, reg
+#ifdef LINUX64
+    lea   \symbol(%rip), \reg
+#else
+/* The real code on x86 would look like this (get `bar' from `foo'):
+ *
+ * 00000198 <bar>:
+ * 198:   c3                      ret
+ *
+ * 00000199 <foo>:
+ * 199:   e8 00 00 00 00          call   19e <foo+0x5>
+ * 19e:   58                      pop    %eax
+ * 19f:   8d 40 fa                lea    -0x6(%eax),%eax
+ */
+    call  . + 0x5 /* No label here to avoid interfering w/ calling code */
+    pop   \reg
+    lea   (\symbol - . + 1)(\reg), \reg
+#endif
+.endm
+
+.globl do_std
+.type do_std, @function
+do_std:
+   push %rbx
+   lea_pic     g_do_std, %xax
+   mov         naked_arg0, %xbx
+   mov         %xbx, (%xax)
+   lea_pic     g_prev_df, %xax
+   mov         (%xax), %xax
+   pop %xbx
+   ret
+
 .globl __morestack
 .type __morestack, @function
 __morestack:
@@ -73,6 +154,14 @@ __morestack:
     mov HOST_CONTEXT, %rdi
     call oe_snap_current_context@PLT
 
+    // Overwrite direction flag
+    lea_pic g_do_std, %xax
+    mov (%xax), %xax
+    cmp $0, %xax
+    je 1f
+    std 
+    1:
+
     // Save the stack pointer so enclave can use the stack.
     mov %rsp, RSP
 
@@ -94,6 +183,18 @@ __morestack:
     mov $ENCLU_EENTER, %rax
     ENCLU
 
+    // Restore direction flag
+    push %xax
+    push %xbx
+    pushf
+    lea_pic g_prev_df, %xbx
+    mov (%xsp), %xax
+    mov %xax, (%xbx)
+    popf
+    pop %xbx
+    pop %xax
+    cld
+
     // Align the stack since enclave code change the host rsp for call out.
     and $-16, %rsp
 
diff --git a/include/openenclave/host.h b/include/openenclave/host.h
index 513d92e..196e82f 100644
--- a/include/openenclave/host.h
+++ b/include/openenclave/host.h
@@ -53,6 +53,13 @@ OE_EXTERNC_BEGIN
  * @endcond
  */
 
+#ifndef __ASSEMBLER__
+void do_std(int std);
+
+#define oe_do_std(val) do_std(val)
+
+#endif
+
 /**
  * Type of each function in an ocall-table.
  */
diff --git a/samples/helloworld/enclave/Makefile b/samples/helloworld/enclave/Makefile
index 2d3fa65..b56c2a2 100644
--- a/samples/helloworld/enclave/Makefile
+++ b/samples/helloworld/enclave/Makefile
@@ -14,7 +14,7 @@ ifeq ($(USE_GCC),)
         COMPILER=clang
 endif
 
-CFLAGS=$(shell pkg-config oeenclave-$(COMPILER) --cflags)
+CFLAGS=$(shell pkg-config oeenclave-$(COMPILER) --cflags) -Os
 LDFLAGS=$(shell pkg-config oeenclave-$(COMPILER) --libs)
 
 all:
diff --git a/samples/helloworld/enclave/enc.c b/samples/helloworld/enclave/enc.c
index 512ef5f..2f8fac4 100644
--- a/samples/helloworld/enclave/enc.c
+++ b/samples/helloworld/enclave/enc.c
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 
 #include <stdio.h>
+#include <string.h>
 
 // Include the trusted helloworld header that is generated
 // during the build. This file is generated by calling the
@@ -31,3 +32,21 @@ void enclave_helloworld()
             oe_result_str(result));
     }
 }
+
+char buf[] = {'A', 0x00, 'B', 'C', 'D', 0x00};
+
+int ecall_strlen( void )
+{
+    //asm ("std");
+    int rv = strlen(&buf[4]);
+    //asm ("cld");
+    return rv;
+}
+
+void ecall_memset( char *out )
+{
+    //asm ("std");
+    memset(&out[50], 'A', 50);
+    //asm ("cld");
+}
+
diff --git a/samples/helloworld/helloworld.edl b/samples/helloworld/helloworld.edl
index 81e4813..fbaee75 100644
--- a/samples/helloworld/helloworld.edl
+++ b/samples/helloworld/helloworld.edl
@@ -4,6 +4,8 @@
 enclave {
     trusted {
         public void enclave_helloworld();
+        public int ecall_strlen( void );
+      	public void ecall_memset( [user_check] char *out );
     };
 
     untrusted {
diff --git a/samples/helloworld/host/host.c b/samples/helloworld/host/host.c
index 4e7f85f..f9d7b52 100644
--- a/samples/helloworld/host/host.c
+++ b/samples/helloworld/host/host.c
@@ -64,17 +64,44 @@ int main(int argc, const char* argv[])
     }
 
     // Call into the enclave
-    result = enclave_helloworld(enclave);
+    int len = 0;
+
+    oe_do_std(0);
+
+    result = ecall_strlen(enclave, &len);
+
+    oe_do_std(0);
+
+    if (result != OE_OK)
+    {
+        fprintf(
+            stderr,
+            "calling into strlen ecall failed: result=%u (%s)\n",
+            result,
+            oe_result_str(result));
+        goto exit;
+    }
+
+    printf("ecall_strlen() with DF = 0 returned %d\n", len);
+
+    oe_do_std(1);
+
+    result = ecall_strlen(enclave, &len);
+
+    oe_do_std(0);
+
     if (result != OE_OK)
     {
         fprintf(
             stderr,
-            "calling into enclave_helloworld failed: result=%u (%s)\n",
+            "calling into strlen ecall failed: result=%u (%s)\n",
             result,
             oe_result_str(result));
         goto exit;
     }
 
+    printf("ecall_strlen() with DF = 1 returned %d\n", len);
+
     ret = 0;
 
 exit:
